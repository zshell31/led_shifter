/* Automatically generated by Ferrum HDL. */

module top_module
(
    // Inputs
    input wire clk,
    // Outputs
    output wire led0,
    output wire led1,
    output wire led2,
    output wire led3
);

    wire __out;
    wire __out_1;
    wire __out_2;
    wire __out_3;
    leds __leds (
        // Inputs
        .clk(clk),
        .rst(1'd0),
        // Outputs
        .__out_2(__out),
        .__out_3(__out_1),
        .__out_4(__out_2),
        .__out_5(__out_3)
    );

    assign led0 = __out;

    assign led1 = __out_1;

    assign led2 = __out_2;

    assign led3 = __out_3;

endmodule

module leds
(
    // Inputs
    input wire clk,
    input wire rst,
    // Outputs
    output wire __out_2,
    output wire __out_3,
    output wire __out_4,
    output wire __out_5
);

    wire shift_c;
    wire en;
    Counter$succ __Counter$succ (
        // Inputs
        .self0(dff[1]),
        // Outputs
        .value(shift_c),
        .succ(en)
    );

    reg [1:0] dff;
    initial begin
        dff = 2'd0;
    end
    always @(posedge clk or posedge rst) begin
        if (rst)
            dff <= 2'd0;
        else
            dff <= { shift_c, en };
    end

    wire [4:0] counter;
    wire change;
    Counter$succ_1 __Counter$succ_1 (
        // Inputs
        .self0(dff_en[8 +: 5]),
        // Outputs
        .value(counter),
        .succ(change)
    );

    wire [7:0] __out;
    State$change __State$change (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .__out(__out)
    );

    wire [7:0] __out_1;
    State$shift __State$shift (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .__out(__out_1)
    );

    wire [7:0] mux2;
    always @(*) begin
        case (change)
            1'h0: 
                mux2 = __out_1;
            default: 
                mux2 = __out;
        endcase
    end

    reg [12:0] dff_en;
    initial begin
        dff_en = 13'd15;
    end
    always @(posedge clk or posedge rst) begin
        if (rst)
            dff_en <= 13'd15;
        else if (dff[0])
            dff_en <= { counter, mux2 };
    end

    State$to_array __State$to_array (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .__out(__out_2),
        .__out_1(__out_3),
        .__out_2(__out_4),
        .__out_3(__out_5)
    );

endmodule

module Counter$succ
(
    // Inputs
    input wire self0,
    // Outputs
    output wire value,
    output wire succ
);

    wire max;
    Counter$is_max __Counter$is_max (
        // Inputs
        .self0(self0),
        // Outputs
        .max(max)
    );

    wire [1:0] mux2;
    always @(*) begin
        case (max)
            1'h0: 
                mux2 = { self0 + 1'd1, 1'd0 };
            default: 
                mux2 = 2'd1;
        endcase
    end

    assign value = mux2[1];

    assign succ = mux2[0];

endmodule

module Counter$is_max
(
    // Inputs
    input wire self0,
    // Outputs
    output wire max
);

    assign max = self0 == 1'd0;

endmodule

module Counter$succ_1
(
    // Inputs
    input wire [4:0] self0,
    // Outputs
    output wire [4:0] value,
    output wire succ
);

    wire max;
    Counter$is_max_1 __Counter$is_max (
        // Inputs
        .self0(self0),
        // Outputs
        .max(max)
    );

    wire [5:0] mux2;
    always @(*) begin
        case (max)
            1'h0: 
                mux2 = { self0 + 5'd1, 1'd0 };
            default: 
                mux2 = 6'd1;
        endcase
    end

    assign value = mux2[1 +: 5];

    assign succ = mux2[0];

endmodule

module Counter$is_max_1
(
    // Inputs
    input wire [4:0] self0,
    // Outputs
    output wire max
);

    assign max = self0 == 5'd28;

endmodule

module State$change
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire [7:0] __out
);

    wire [7:0] mux;
    always @(*) begin
        case (self$[7])
            1'b0 : mux = 8'd248;
            default: mux = 8'd15;
        endcase
    end

    assign __out = mux;

endmodule

module State$shift
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire [7:0] __out
);

    wire [6:0] mux2;
    always @(*) begin
        case (self$[0 +: 7] == 7'd0)
            1'h0: 
                mux2 = self$[0 +: 7] << 7'd1;
            default: 
                mux2 = 7'd15;
        endcase
    end

    wire [6:0] mux2_1;
    always @(*) begin
        case (self$[0 +: 7] == 7'd0)
            1'h0: 
                mux2_1 = self$[0 +: 7] >> 7'd1;
            default: 
                mux2_1 = 7'd120;
        endcase
    end

    wire [7:0] mux;
    always @(*) begin
        case (self$[7])
            1'b0 : mux = { 1'd0, { mux2 } };
            default: mux = { 1'd1, { mux2_1 } };
        endcase
    end

    assign __out = mux;

endmodule

module State$to_array
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire __out,
    output wire __out_1,
    output wire __out_2,
    output wire __out_3
);

    wire [6:0] left;
    assign left = self$[0 +: 7];

    wire [3:0] __tmp;
    assign __tmp = left[3 +: 4];

    wire [6:0] right;
    assign right = self$[0 +: 7];

    wire [3:0] __tmp_6;
    assign __tmp_6 = right[0 +: 4];

    wire [3:0] mux;
    always @(*) begin
        case (self$[7])
            1'b0 : mux = { __tmp[3], __tmp[2], __tmp[1], __tmp[0] };
            default: mux = { __tmp_6[3], __tmp_6[2], __tmp_6[1], __tmp_6[0] };
        endcase
    end

    assign __out = mux[3];

    assign __out_1 = mux[2];

    assign __out_2 = mux[1];

    assign __out_3 = mux[0];

endmodule

