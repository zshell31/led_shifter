/* Automatically generated by Ferrum HDL. */

module top_module
(
    // Inputs
    input wire clk,
    // Outputs
    output wire led$0,
    output wire led$1,
    output wire led$2,
    output wire led$3
);

    leds __leds (
        // Inputs
        .clk(clk),
        .rst(1'd0),
        // Outputs
        .out(led$0),
        .out_1(led$1),
        .out_2(led$2),
        .out_3(led$3)
    );

endmodule

module leds
(
    // Inputs
    input wire clk,
    input wire rst,
    // Outputs
    output wire out,
    output wire out_1,
    output wire out_2,
    output wire out_3
);

    reg [2:0] dff;
    initial begin
        dff = 3'd0;
    end
    always @(posedge clk or posedge rst) begin
        if (rst)
            dff <= 3'd0;
        else
            dff <= { shift_c_1, en_1 };
    end

    wire [1:0] shift_c_1;
    wire en_1;
    Counter$succ __Counter$succ (
        // Inputs
        .self$(dff[1 +: 2]),
        // Outputs
        .value(shift_c_1),
        .succ(en_1)
    );

    reg [12:0] dff_en;
    initial begin
        dff_en = 13'd15;
    end
    always @(posedge clk or posedge rst) begin
        if (rst)
            dff_en <= 13'd15;
        else if (dff[0])
            dff_en <= { counter_1, state_1 };
    end

    wire [4:0] counter_1;
    wire change;
    Counter$succ_1 __Counter$succ_1 (
        // Inputs
        .self$(dff_en[8 +: 5]),
        // Outputs
        .value(counter_1),
        .succ(change)
    );

    wire [7:0] mux;
    State$change __State$change (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .mux(mux)
    );

    wire [7:0] mux_1;
    State$shift __State$shift (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .mux_2(mux_1)
    );

    wire [7:0] state_1;
    always @(*) begin
        case (change)
            1'h0: 
                state_1 = mux_1;
            default: 
                state_1 = mux;
        endcase
    end

    State$to_array __State$to_array (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .out(out),
        .out_1(out_1),
        .out_2(out_2),
        .out_3(out_3)
    );

endmodule

module Counter$succ
(
    // Inputs
    input wire [1:0] self$,
    // Outputs
    output wire [1:0] value,
    output wire succ
);

    wire [2:0] mux;
    always @(*) begin
        case (self$ == 2'd1)
            1'h0: 
                mux = { self$ + 2'd1, 1'd0 };
            default: 
                mux = 3'd1;
        endcase
    end

    assign value = mux[1 +: 2];

    assign succ = mux[0];

endmodule

module Counter$succ_1
(
    // Inputs
    input wire [4:0] self$,
    // Outputs
    output wire [4:0] value,
    output wire succ
);

    wire [5:0] mux;
    always @(*) begin
        case (self$ == 5'd15)
            1'h0: 
                mux = { self$ + 5'd1, 1'd0 };
            default: 
                mux = 6'd1;
        endcase
    end

    assign value = mux[1 +: 5];

    assign succ = mux[0];

endmodule

module State$change
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire [7:0] mux
);

    always @(*) begin
        case (self$[7])
            1'b0 : mux = 8'd248;
            default: mux = 8'd15;
        endcase
    end

endmodule

module State$shift
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire [7:0] mux_2
);

    wire [6:0] mux;
    always @(*) begin
        case (self$[0 +: 7] == 7'd0)
            1'h0: 
                mux = self$[0 +: 7] << 7'd1;
            default: 
                mux = 7'd15;
        endcase
    end

    wire [6:0] mux_1;
    always @(*) begin
        case (self$[0 +: 7] == 7'd0)
            1'h0: 
                mux_1 = self$[0 +: 7] >> 7'd1;
            default: 
                mux_1 = 7'd120;
        endcase
    end

    always @(*) begin
        case (self$[7])
            1'b0 : mux_2 = { 1'd0, mux };
            default: mux_2 = { 1'd1, mux_1 };
        endcase
    end

endmodule

module State$to_array
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire out,
    output wire out_1,
    output wire out_2,
    output wire out_3
);

    wire [6:0] left;
    assign left = self$[0 +: 7];

    wire [3:0] left_slice;
    assign left_slice = left[3 +: 4];

    wire [6:0] right;
    assign right = self$[0 +: 7];

    wire [3:0] right_slice;
    assign right_slice = right[0 +: 4];

    wire [3:0] mux;
    always @(*) begin
        case (self$[7])
            1'b0 : mux = { left_slice[3], left_slice[2], left_slice[1], left_slice[0] };
            default: mux = { right_slice[3], right_slice[2], right_slice[1], right_slice[0] };
        endcase
    end

    assign out = mux[3];

    assign out_1 = mux[2];

    assign out_2 = mux[1];

    assign out_3 = mux[0];

endmodule

