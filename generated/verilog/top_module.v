/* Automatically generated by Ferrum. */

module top_module
(
    // Inputs
    input wire clk,
    // Outputs
    output wire led,
    output wire led_1,
    output wire led_2,
    output wire led_3
);

    wire rst;
    assign rst = 0;

    wire led;
    wire led_1;
    wire led_2;
    wire led_3;
    leds __leds (
        // Inputs
        .clk(clk),
        .rst(rst),
        // Outputs
        .__out(led),
        .__out_1(led_1),
        .__out_2(led_2),
        .__out_3(led_3)
    );

    assign led = led;

    assign led_1 = led_1;

    assign led_2 = led_2;

    assign led_3 = led_3;

endmodule

module leds
(
    // Inputs
    input wire clk,
    input wire rst,
    // Outputs
    output wire __out,
    output wire __out_1,
    output wire __out_2,
    output wire __out_3
);

    wire [22:0] shift_c_1;
    wire en;
    Counter$succ __Counter$succ (
        // Inputs
        .self$(__tmp_22),
        // Outputs
        .value(shift_c_1),
        .bit(en)
    );

    reg [23:0] __tmp_16;
    initial begin
        __tmp_16 = { 23'd0, 1'd0 };
    end
    always @ (posedge clk or posedge rst) begin
        if (rst)
            __tmp_16 <= { 23'd0, 1'd0 };
        else
            __tmp_16 <= { shift_c_1, en };
    end

    wire [22:0] __tmp_22;
    assign __tmp_22 = __tmp_16[1 +: 23];

    wire en_2;
    assign en_2 = __tmp_16[0];

    wire [4:0] counter_1;
    wire change;
    Counter$succ_1 __Counter$succ_1 (
        // Inputs
        .self$(__tmp_50),
        // Outputs
        .value(counter_1),
        .bit(change)
    );

    wire [7:0] __tmp_36;
    State$change __State$change (
        // Inputs
        .self$(state_2),
        // Outputs
        .__tmp_19(__tmp_36)
    );

    wire [7:0] __tmp_37;
    State$shift __State$shift (
        // Inputs
        .self$(state_2),
        // Outputs
        .__tmp_35(__tmp_37)
    );

    wire [7:0] state_1;
    always @ (*) begin
        case (change)
            1'h0: 
                state_1 = __tmp_37;
            default: 
                state_1 = __tmp_36;
        endcase
    end

    reg [12:0] __tmp_44;
    initial begin
        __tmp_44 = { 5'd0, { 1'd0, 7'd15 } };
    end
    always @ (posedge clk or posedge rst) begin
        if (rst)
            __tmp_44 <= { 5'd0, { 1'd0, 7'd15 } };
        else if (en_2)
            __tmp_44 <= { counter_1, state_1 };
    end

    wire [4:0] __tmp_50;
    assign __tmp_50 = __tmp_44[8 +: 5];

    wire [7:0] state_2;
    assign state_2 = __tmp_44[0 +: 8];

    wire __out;
    wire __out_1;
    wire __out_2;
    wire __out_3;
    State$to_array __State$to_array (
        // Inputs
        .self$(state_2),
        // Outputs
        .__tmp_43(__out),
        .__tmp_44(__out_1),
        .__tmp_45(__out_2),
        .__tmp_46(__out_3)
    );

endmodule

module Counter$succ
(
    // Inputs
    input wire [22:0] self$,
    // Outputs
    output wire [22:0] value,
    output wire bit
);

    wire __tmp_1;
    Counter$is_max __Counter$is_max (
        // Inputs
        .self$(self$),
        // Outputs
        .__out(__tmp_1)
    );

    wire [23:0] __tmp_15;
    always @ (*) begin
        case (__tmp_1)
            1'h0: 
                __tmp_15 = { self$ + 23'd1, 1'd0 };
            default: 
                __tmp_15 = { 23'd0, 1'd1 };
        endcase
    end

    wire [22:0] value;
    assign value = __tmp_15[1 +: 23];

    wire bit;
    assign bit = __tmp_15[0];

endmodule

module Counter$is_max
(
    // Inputs
    input wire [22:0] self$,
    // Outputs
    output wire __out
);

    wire __out;
    assign __out = self$ == 23'd6249999;

endmodule

module Counter$succ_1
(
    // Inputs
    input wire [4:0] self$,
    // Outputs
    output wire [4:0] value,
    output wire bit
);

    wire __tmp_1;
    Counter$is_max_1 __Counter$is_max_1 (
        // Inputs
        .self$(self$),
        // Outputs
        .__out(__tmp_1)
    );

    wire [5:0] __tmp_15;
    always @ (*) begin
        case (__tmp_1)
            1'h0: 
                __tmp_15 = { self$ + 5'd1, 1'd0 };
            default: 
                __tmp_15 = { 5'd0, 1'd1 };
        endcase
    end

    wire [4:0] value;
    assign value = __tmp_15[1 +: 5];

    wire bit;
    assign bit = __tmp_15[0];

endmodule

module Counter$is_max_1
(
    // Inputs
    input wire [4:0] self$,
    // Outputs
    output wire __out
);

    wire __out;
    assign __out = self$ == 5'd28;

endmodule

module State$change
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire [7:0] __tmp_19
);

    wire [7:0] __tmp_18;
    always @(*) begin
        case (self$[7])
            1'b0 : __tmp_18 = { 1'd1, 7'd120 };
            default: __tmp_18 = { 1'd0, 7'd15 };
        endcase
    end

    wire [7:0] __tmp_19;
    assign __tmp_19 = __tmp_18;

endmodule

module State$shift
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire [7:0] __tmp_35
);

    wire [6:0] __tmp_11;
    always @ (*) begin
        case (self$[0 +: 7] == 7'd0)
            1'h0: 
                __tmp_11 = self$[0 +: 7] << 7'd1;
            default: 
                __tmp_11 = 7'd15;
        endcase
    end

    wire [6:0] __tmp_27;
    always @ (*) begin
        case (self$[0 +: 7] == 7'd0)
            1'h0: 
                __tmp_27 = self$[0 +: 7] >> 7'd1;
            default: 
                __tmp_27 = 7'd120;
        endcase
    end

    wire [7:0] __tmp_34;
    always @(*) begin
        case (self$[7])
            1'b0 : __tmp_34 = { 1'd0, __tmp_11 };
            default: __tmp_34 = { 1'd1, __tmp_27 };
        endcase
    end

    wire [7:0] __tmp_35;
    assign __tmp_35 = __tmp_34;

endmodule

module State$to_array
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire __tmp_43,
    output wire __tmp_44,
    output wire __tmp_45,
    output wire __tmp_46
);

    wire [6:0] left;
    assign left = self$[0 +: 7];

    wire [3:0] __tmp_5;
    assign __tmp_5 = left[3 +: 4];

    wire [6:0] right;
    assign right = self$[0 +: 7];

    wire [3:0] __tmp_23;
    assign __tmp_23 = right[0 +: 4];

    wire [3:0] __tmp_38;
    always @(*) begin
        case (self$[7])
            1'b0 : __tmp_38 = { __tmp_5[3], __tmp_5[2], __tmp_5[1], __tmp_5[0] };
            default: __tmp_38 = { __tmp_23[3], __tmp_23[2], __tmp_23[1], __tmp_23[0] };
        endcase
    end

    wire __tmp_43;
    assign __tmp_43 = __tmp_38[3];

    wire __tmp_44;
    assign __tmp_44 = __tmp_38[2];

    wire __tmp_45;
    assign __tmp_45 = __tmp_38[1];

    wire __tmp_46;
    assign __tmp_46 = __tmp_38[0];

endmodule

