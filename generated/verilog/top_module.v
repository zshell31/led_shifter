/* Automatically generated by Ferrum HDL. */

module top_module
(
    // Inputs
    input wire clk,
    // Outputs
    output wire led,
    output wire led_1,
    output wire led_2,
    output wire led_3
);

    wire __tmp_3;
    wire __tmp_4;
    wire __tmp_5;
    wire __tmp_6;
    leds __leds (
        // Inputs
        .clk(clk),
        .rst(1'd0),
        // Outputs
        .__out(__tmp_3),
        .__out_1(__tmp_4),
        .__out_2(__tmp_5),
        .__out_3(__tmp_6)
    );

    wire led;
    assign led = __tmp_3;

    wire led_1;
    assign led_1 = __tmp_4;

    wire led_2;
    assign led_2 = __tmp_5;

    wire led_3;
    assign led_3 = __tmp_6;

endmodule

module leds
(
    // Inputs
    input wire clk,
    input wire rst,
    // Outputs
    output wire __out,
    output wire __out_1,
    output wire __out_2,
    output wire __out_3
);

    wire __tmp_9;
    wire __tmp_10;
    Counter$succ __Counter$succ (
        // Inputs
        .self$(__tmp_16[1]),
        // Outputs
        .value(__tmp_9),
        .bit(__tmp_10)
    );

    reg [1:0] __tmp_16;
    initial begin
        __tmp_16 = { 1'd0, 1'd0 };
    end
    always @(posedge clk or posedge rst) begin
        if (rst)
            __tmp_16 <= { 1'd0, 1'd0 };
        else
            __tmp_16 <= { __tmp_9, __tmp_10 };
    end

    wire __tmp_17;
    assign __tmp_17 = __tmp_16[1];

    wire __tmp_18;
    assign __tmp_18 = __tmp_16[0];

    wire [4:0] __tmp_32;
    wire __tmp_33;
    Counter$succ_1 __Counter$succ_1 (
        // Inputs
        .self$(__tmp_44[8 +: 5]),
        // Outputs
        .value(__tmp_32),
        .bit(__tmp_33)
    );

    wire [7:0] __tmp_36;
    State$change __State$change (
        // Inputs
        .self$(__tmp_44[0 +: 8]),
        // Outputs
        .__tmp_20(__tmp_36)
    );

    wire [7:0] __tmp_37;
    State$shift __State$shift (
        // Inputs
        .self$(__tmp_44[0 +: 8]),
        // Outputs
        .__tmp_36(__tmp_37)
    );

    wire [7:0] __tmp_38;
    always @(*) begin
        case (__tmp_33)
            1'h0: 
                __tmp_38 = __tmp_37;
            default: 
                __tmp_38 = __tmp_36;
        endcase
    end

    reg [12:0] __tmp_44;
    initial begin
        __tmp_44 = { 5'd0, { 1'd0, 7'd15 } };
    end
    always @(posedge clk or posedge rst) begin
        if (rst)
            __tmp_44 <= { 5'd0, { 1'd0, 7'd15 } };
        else if (__tmp_18)
            __tmp_44 <= { __tmp_32, __tmp_38 };
    end

    wire __out;
    wire __out_1;
    wire __out_2;
    wire __out_3;
    State$to_array __State$to_array (
        // Inputs
        .self$(__tmp_44[0 +: 8]),
        // Outputs
        .__tmp_44(__out),
        .__tmp_45(__out_1),
        .__tmp_46(__out_2),
        .__tmp_47(__out_3)
    );

endmodule

module Counter$succ
(
    // Inputs
    input wire self$,
    // Outputs
    output wire value,
    output wire bit
);

    wire __tmp_1;
    Counter$is_max __Counter$is_max (
        // Inputs
        .self$(self$),
        // Outputs
        .__out(__tmp_1)
    );

    wire [1:0] __tmp_15;
    always @(*) begin
        case (__tmp_1)
            1'h0: 
                __tmp_15 = { self$ + 1'd1, 1'd0 };
            default: 
                __tmp_15 = { 1'd0, 1'd1 };
        endcase
    end

    wire value;
    assign value = __tmp_15[1];

    wire bit;
    assign bit = __tmp_15[0];

endmodule

module Counter$is_max
(
    // Inputs
    input wire self$,
    // Outputs
    output wire __out
);

    wire __out;
    assign __out = self$ == 1'd0;

endmodule

module Counter$succ_1
(
    // Inputs
    input wire [4:0] self$,
    // Outputs
    output wire [4:0] value,
    output wire bit
);

    wire __tmp_1;
    Counter$is_max_1 __Counter$is_max_1 (
        // Inputs
        .self$(self$),
        // Outputs
        .__out(__tmp_1)
    );

    wire [5:0] __tmp_15;
    always @(*) begin
        case (__tmp_1)
            1'h0: 
                __tmp_15 = { self$ + 5'd1, 1'd0 };
            default: 
                __tmp_15 = { 5'd0, 1'd1 };
        endcase
    end

    wire [4:0] value;
    assign value = __tmp_15[1 +: 5];

    wire bit;
    assign bit = __tmp_15[0];

endmodule

module Counter$is_max_1
(
    // Inputs
    input wire [4:0] self$,
    // Outputs
    output wire __out
);

    wire __out;
    assign __out = self$ == 5'd28;

endmodule

module State$change
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire [7:0] __tmp_20
);

    wire [7:0] __tmp_19;
    always @(*) begin
        case (self$[7])
            1'b0 : __tmp_19 = { 1'd1, 7'd120 };
            default: __tmp_19 = { 1'd0, 7'd15 };
        endcase
    end

    wire [7:0] __tmp_20;
    assign __tmp_20 = __tmp_19;

endmodule

module State$shift
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire [7:0] __tmp_36
);

    wire [6:0] __tmp_11;
    always @(*) begin
        case (self$[0 +: 7] == 7'd0)
            1'h0: 
                __tmp_11 = self$[0 +: 7] << 7'd1;
            default: 
                __tmp_11 = 7'd15;
        endcase
    end

    wire [6:0] __tmp_27;
    always @(*) begin
        case (self$[0 +: 7] == 7'd0)
            1'h0: 
                __tmp_27 = self$[0 +: 7] >> 7'd1;
            default: 
                __tmp_27 = 7'd120;
        endcase
    end

    wire [7:0] __tmp_35;
    always @(*) begin
        case (self$[7])
            1'b0 : __tmp_35 = { 1'd0, __tmp_11 };
            default: __tmp_35 = { 1'd1, __tmp_27 };
        endcase
    end

    wire [7:0] __tmp_36;
    assign __tmp_36 = __tmp_35;

endmodule

module State$to_array
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire __tmp_44,
    output wire __tmp_45,
    output wire __tmp_46,
    output wire __tmp_47
);

    wire [6:0] __tmp_1;
    assign __tmp_1 = self$[0 +: 7];

    wire [3:0] __tmp_5;
    assign __tmp_5 = __tmp_1[3 +: 4];

    wire [6:0] __tmp_19;
    assign __tmp_19 = self$[0 +: 7];

    wire [3:0] __tmp_23;
    assign __tmp_23 = __tmp_19[0 +: 4];

    wire [3:0] __tmp_39;
    always @(*) begin
        case (self$[7])
            1'b0 : __tmp_39 = { __tmp_5[3], __tmp_5[2], __tmp_5[1], __tmp_5[0] };
            default: __tmp_39 = { __tmp_23[3], __tmp_23[2], __tmp_23[1], __tmp_23[0] };
        endcase
    end

    wire __tmp_44;
    assign __tmp_44 = __tmp_39[3];

    wire __tmp_45;
    assign __tmp_45 = __tmp_39[2];

    wire __tmp_46;
    assign __tmp_46 = __tmp_39[1];

    wire __tmp_47;
    assign __tmp_47 = __tmp_39[0];

endmodule

