/* Automatically generated by Ferrum HDL. */

module top_module
(
    // Inputs
    input wire clk,
    // Outputs
    output wire led$0,
    output wire led$1,
    output wire led$2,
    output wire led$3
);

    leds __leds (
        // Inputs
        .clk(clk),
        .rst(1'd0),
        // Outputs
        .out$0(led$0),
        .out$1(led$1),
        .out$2(led$2),
        .out$3(led$3)
    );

endmodule

module leds
(
    // Inputs
    input wire clk,
    input wire rst,
    // Outputs
    output wire out$0,
    output wire out$1,
    output wire out$2,
    output wire out$3
);

    reg [2:0] dff;
    initial begin
        dff = 3'd0;
    end
    wire [2:0] __tmp_2;
    always @(posedge clk or posedge rst) begin
        if (rst)
            dff <= 3'd0;
        else
            dff <= __tmp_2;
    end

    wire en;
    assign en = dff[0];

    wire [1:0] shift_c;
    wire en_1;
    counter_Counter_N_succ __counter_Counter_N_succ (
        // Inputs
        .self$(dff[1 +: 2]),
        // Outputs
        .value(shift_c),
        .succ(en_1)
    );

    assign __tmp_2 = {
        shift_c,
        en_1
    };

    reg [12:0] dff_en;
    initial begin
        dff_en = 13'd15;
    end
    wire [12:0] __tmp_6;
    always @(posedge clk or posedge rst) begin
        if (rst)
            dff_en <= 13'd15;
        else if (en)
            dff_en <= __tmp_6;
    end

    wire [4:0] counter;
    wire change;
    counter_Counter_N_succ_1 __counter_Counter_N_succ_1 (
        // Inputs
        .self$(dff_en[8 +: 5]),
        // Outputs
        .value(counter),
        .succ(change)
    );

    wire [7:0] mux;
    state_State_shift __state_State_shift (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .mux_2(mux)
    );

    wire [7:0] mux_1;
    state_State_change __state_State_change (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .mux(mux_1)
    );

    reg [7:0] state;
    always @(*) begin
        case (change)
            1'b0 : state = mux;
            default: state = mux_1;
        endcase
    end

    assign __tmp_6 = {
        counter,
        state
    };

    state_State_to_array __state_State_to_array (
        // Inputs
        .self$(dff_en[0 +: 8]),
        // Outputs
        .out$0(out$0),
        .out$1(out$1),
        .out$2(out$2),
        .out$3(out$3)
    );

endmodule

module counter_Counter_N_succ
(
    // Inputs
    input wire [1:0] self$,
    // Outputs
    output wire [1:0] value,
    output wire succ
);

    reg [2:0] mux;
    always @(*) begin
        case (self$ == 2'd1)
            1'b0 : mux = { self$ + 2'd1, 1'd0 };
            default: mux = 3'd1;
        endcase
    end

    assign value = mux[1 +: 2];

    assign succ = mux[0];

endmodule

module counter_Counter_N_succ_1
(
    // Inputs
    input wire [4:0] self$,
    // Outputs
    output wire [4:0] value,
    output wire succ
);

    reg [5:0] mux;
    always @(*) begin
        case (self$ == 5'd15)
            1'b0 : mux = { self$ + 5'd1, 1'd0 };
            default: mux = 6'd1;
        endcase
    end

    assign value = mux[1 +: 5];

    assign succ = mux[0];

endmodule

module state_State_shift
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output reg [7:0] mux_2
);

    reg [6:0] mux;
    always @(*) begin
        case (self$[0 +: 7] == 7'd0)
            1'b0 : mux = self$[0 +: 7] << 7'd1;
            default: mux = 7'd15;
        endcase
    end

    reg [6:0] mux_1;
    always @(*) begin
        case (self$[0 +: 7] == 7'd0)
            1'b0 : mux_1 = self$[0 +: 7] >> 7'd1;
            default: mux_1 = 7'd120;
        endcase
    end

    always @(*) begin
        case (self$[7])
            1'b0 : mux_2 = { 1'd0, mux };
            default: mux_2 = { 1'd1, mux_1 };
        endcase
    end

endmodule

module state_State_change
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output reg [7:0] mux
);

    always @(*) begin
        case (self$[7])
            1'b0 : mux = 8'd248;
            default: mux = 8'd15;
        endcase
    end

endmodule

module state_State_to_array
(
    // Inputs
    input wire [7:0] self$,
    // Outputs
    output wire out$0,
    output wire out$1,
    output wire out$2,
    output wire out$3
);

    wire [6:0] left;
    assign left = self$[0 +: 7];

    wire [3:0] __tmp;
    assign __tmp = left[3 +: 4];

    wire [6:0] right;
    assign right = self$[0 +: 7];

    wire [3:0] __tmp_5;
    assign __tmp_5 = right[0 +: 4];

    reg [3:0] mux;
    always @(*) begin
        case (self$[7])
            1'b0 : mux = { __tmp[3], __tmp[2], __tmp[1], __tmp[0] };
            default: mux = { __tmp_5[3], __tmp_5[2], __tmp_5[1], __tmp_5[0] };
        endcase
    end

    assign out$0 = mux[3];

    assign out$1 = mux[2];

    assign out$2 = mux[1];

    assign out$3 = mux[0];

endmodule

